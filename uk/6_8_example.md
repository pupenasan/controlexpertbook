## 6.8. Приклади

### 6.8.1. Стабілізаційне регулювання 

Завдання. 

Створити проект для ПЛК М340, для реалізації програми управління установкою, що описується наступним алгоритмом (див. рис.6.59). Після нажимання кнопки "СТАРТ" відкривається клапан набору першого продукту. Після досягнення середнього рівня клапан 1-го продукту закривається, відкривається клапан набору 2-го продукту. Після спрацювання сигналізатору верхнього рівня закривається клапан набору 2-го продукту, відкривається клапан пари на 100% (діапазон виходу 0-100%). Після досягнення температури 95ºС (діапазон датчику 0-150ºС) включається етап витримки. Витримка повинна тривати 3 хвилини, в цей час регулятор повинен підтримувати температуру на заданому рівні. Задане значення температури визначає оператор. Програму перевірити та налагодити з використанням операторських екранів.

Після закінчення витримки, рідина зливається з апарату. Після відключення сигналізатору нижнього рівня, цикл повторюється у випадку якщо кнопка СТОП не нажата. Якщо СТОП нажата – клапан зливу закривається. У ПЛК поступає сигнал від датчика рівня з діапазоном вимірювання 0-5 м. 

Рішення. 

Робота програми описується алгоритмом, наведеним в главі 5.8 за винятком етапу витримки. Модифікована частина програми показана на рис.6.60, перелік змінних та екземплярів функціональних блоків наведений на рис.6.61 та рис.6.62. 

Змінна що відповідає за управління виконавчим механізмом *VR_par_R* управляється регулятором *TIC1*, який реалізовує ПІ закон управління. Регулятор викликається кожні 100 мс, оскільки його вхід *EN* підключений до блоку *SMPL1*. Ручне управління клапаном *VR_par_R* забезпечується через функцію *SEL* (".16"), який перемикає *VR_par_R*  на значення *VR_par_MAN*. Для безударності переходу замість *SEL* можна використання блок *MS*. 

Регулятор *TIC1* працює в режимі регулювання тільки при (*StepProg=4*), в інших випадках він працює в режимі слідкування, тобто на вихід *TIC1.OUT* буде подаватися значення *TIC1.TR_I.* Таким чином на усіх етапах роботи програми *VR_par_R* буде управлятися значенням з *MUX*, тільки на етапі витримки буде включатися режим регулювання.   

![](media6/6_59.png)

Рис.6.59. Приклад операторського екрану до поставленої задачі

![](media6/6_60.png)

Рис.6.60. Модифікована частина секції програми 

![](media6/6_61.png)

Рис.6.61. Перелік змінних

![](media6/6_62.png)

Рис.6.62. Перелік екземплярів функціональних блоків

### 6.8.2.  Каскадне регулювання

Завдання. 

Необхідно створити проект в UNITY PRO для реалізації поставленої задачі (рис.6.63) з використанням FFB бібліотеки *ControlLIB*. 

![](media6/6_63.png)

Рис.6.63. Операторський екран для контролю та управління процесом нагрівання

Технологічна установка являє собою теплообмінник для підігріву рідкого продукту (рис.6.63) за допомогою гарячої води. Температура продукту на виході вимірюється датчиком температури *TT1* (0-100 °C, вхід ПЛК *%IW0.1.2*) який вмонтований на трубопроводі на відстані кількох метрів від підігрівника, а регулюється витратою гарячої води регулюючим клапаном *TV1* на виході підігрівника (0-100% ХРО, вихід *%QW0.2.0*). Додатково вимірюється також температура води в трубопроводі безпосередньо на виході підігрівника за допомогою датчика *ТТ2* (0-100 °C, вхід ПЛК *%IW0.1.1*). Інерційність об’єкту по каналу *ТТ2* менша ніж по *ТТ1*. 

Система управління повинна забезпечити регулювання температури *ТТ1* з підтримкою наступних функцій:

1)  стабілізація температури на виході підігрівника на заданому оператором або програмним задатчиком значені, з використанням каскадного регулятору, де:

a.   ведучий регулятор (ПІ режим) стабілізує температуру *ТТ1*;

b.   ведений регулятор (П режим) служить для швидкої реакції контуру регулювання на зміну малоінерційного *ТТ2*;

2)  можливість настройки коефіцієнтів *Kp* та *Ti* з операторського екрану;

3)  можливість ручного управління виконавчим механізмом *TV1* з операторського екрану при переключенні в ручний режим з забезпеченням безударності переходу ;

4)  можливість формування завдання програмним задатчиком в залежності від часу по залежності показаній на діаграмі рис. 6.64.

![](media6/6_64.png)

Рис.6.64. Залежність завдання температури від часу

5)  можливість переключення з ручного завдання на програмне управління та навпаки в будь який момент часу з забезпеченням безударності переходу; 

6)  можливість виключення веденого регулятору з каскаду (з забезпеченням безударності переходу), тобто переводу контуру в режим прямого ПІ-регулювання по температурі *ТТ1*;

7)  при ручному управлінні виконавчим механізмом ведучий регулятор повинен фіксувати своє вихідне значення в останньому положенні.

Рішення. 

Загальні принципи роботи контуру. Функціональна схема контуру регулювання температури продукту показана на операторському екрані (рис.6.63). 

Контур включає:

-           канали вимірювання (*ТТ1, ТТ2*);

-           канал формування завдання, який складається з ручного задатчика, програмного задатчика *TK1_sp* (формування програмного управління по часу), перемикача ручного/програмного завдання *HS1sp* (включена кнопка – запуск програмного задатчика) ;

-           ведучого регулятору *TC1* (ПІ закон), який на основі сформованого завдання (вхід *SP*) та вимірювального значення (*TT1* на вхід *PV*), формує сигнал управління (вихід *OUT*), який подається на ведений регулятор *ТС1s*; для регулятору налаштовуються *Kp* та *Ti*; 

-           веденого регулятору *TC1s* (П закон), який на основі сформованого завдання (*TC1.OUT* на вхід *SP*) та вимірювального значення (*TT2* на вхід *PV*), формує сигнал управління (вихід *OUT*), який подається на виконавчий механізм *TV1* через перемикач *TC1s_OFF*; перемикач *TC1s_OFF* дозволяє переключити *TV1* на вихід ведучого регулятору *TC1.OUT*, тим самим відключивши ведений регулятор з контуру управління; для регулятору налаштовується *Kp* а також *Ti*, ненульове значення якого дозволяє перевести регулятор в ПІ-режим;

-           блок ручного управління *HC1*, який дає можливість переключитися в режим ручного управління виконавчим механізмом *TV1* з операторського екрану; кнопка "АВТ" для переключення режиму (нажата - автоматичний режим); 

-           канал управління (*TV1*);

Перелік змінних та екземплярів функціональних блоків наведений на рис.6.65.

![](media6/6_65.png)

Рис.6.65. Змінні проекту

Загальні принципи роботи програми. Для реалізації даної задачі використовуються 4-ри секції (рис.6.66): секція "*INPUTS*" – для обробки вхідних каналів вимірювання (датчики температури); секція "*OUTPUTS*" – для обробки вихідного каналу правління; секція "*CTRL1*" – для реалізації контуру регулювання. Секція "*Simulation*" призначена тільки для імітації об’єкта при налагодженні програми і є необов’язковою.

У секції "*INPUTS*" оцифровані значення аналогових входів масштабуються шляхом множення на коефіцієнт (діапазон *0-10000* в 0-100°C). У секції "*OTPUTS*" аналогічним чином проводиться масштабування для значення виконавчого механізму *TV1*, тільки в зворотному напрямку (діапазон 0-100%ХРО в 0-10000).

![](media6/6_66.png)

Рис.6.66. Структура задачі MAST

Реалізація програмного задатчика. Для реалізації програмного задатчика використана процедура *LOOKUP_TABLE1*, яка реалізовує кусочно-лінійну інтерполяцію за заданими вузловими точками. Вузлові точки задаються парами значень *XiYi*, перше з яких – час в секундах, друга – задане значення температури в цій точці. Таким чином на вході *X* процедура буде отримувати значення часу роботи програмного задатчика в форматі *REAL*, в залежності від якого на виході *Y* буде формуватися задане значення (уставка для регулятору) *TK1_SP*.   

![](media6/6_67.png)

Рис.6.67. Реалізація програмного задатчика

Для формування часу роботи задатчика використовується таймер *TK1*, який стартує по команді запуску задатчика *TK1_ON*, та налаштований на повний час його роботи (240с). Спрацювання виходу *TK1.Q*, тобто по закінченню роботи програмного задатчика, приводить до скидання команди *TK1_ON*. У зв’язку з тим, що вихід таймеру *TK1.ET* видає значення типу *TIME*, воно перетворюється в тип *REAL*, а отримані мілісекунди шляхом ділення на 1000 переводяться в секунди. 

Загальні принципи реалізації контуру регулювання. Фрагмент програми реалізації контуру регулювання показана на рис.6.68. Слід зазначити, що старші версії UNITY PRO (<6.0) не підтримують можливість безпосереднього з’єднання в FBD виходів типу *INOUT* та *IN* (або *OUT*). 

![](media6/6_68.png)

Рис.6.68. Фрагмент секції з реалізацією контуру регулювання (для UNITY PRO ≥6.0) 

Використовуючи *SMPL1* та входи *EN* функціональних блоків, блоки *HS1sp*(перемикача завдань), *TC1*(ведучий регулятор) та *TC1s*(ведений регулятор) викликаються періодично з часом 500 мс, послідовно один за одним. Це дає змогу зменшити навантаження на ресурси ПЛК та виконавчих механізмів в автоматичному режимі. Однак для ручного режиму необхідна швидка реакція системи на дії оператору, тому блок ручного завдання викликається з кожним циклом (вхід *EN* не задіяний). 

Реалізація каналу формування завдання. Вихід блоку *HS1sp.SP* через змінну *TC1_SP* формує завдання для блоку *TC1*, вихід якого в свою чергу формує завдання *TC1s*. Таким чином формується каскадне регулювання. 

Блок перемикання завдання *HS1sp.SP* на вході RSP (дистанційне завдання) отримує значення в змінній *TK1_SP* з програмного задатчика. При активації оператором програмного управління (*TK1_ON=TRUE*), через вхід *SP_RSP* блок *HS1sp* переключається в дистанційний режим, при якому *HS1sp.SP=* *HS1sp.TK1_SP*. Це ж значення копіюється в змінну *TC1_SP*, так як вона прив’язана до входу/виходу *SP*. У локальному режимі (*TK1_ON=FALSE*) оператор може змінювати уставку безпосередньо змінюючи *TIC1*.     

Реалізація каскадного регулятору. Ведучий регулятор *TC1* реалізований через функціональний блок типу *PI_B*. Його задача забезпечити значення температури *TT1* на рівні заданому *TC1_SP*.

Ведений регулятор *TC1s* теж реалізований через функціональний блок типу *PI_B*, однак по замовченню він працює в П-режимі, так як інтегральна складова відключена (*Ti=0*). Його задача швидко зреагувати на зміну менш інерційної змінної процесу *TT2*. Таким чином велику частину збурень швидко компенсує ведений регулятор, а ведучий регулятор забезпечить точність регулювання.  

Враховуючи вимоги до функцій контуру регулювання, ведучий регулятор повинен мати можливість працювати в каскаді з веденим регулятором (*TC1s*), або самостійно без нього. У каскадному режимі вихід регулятору підключається до *TC1s.SP* через змінну *TC1_OUT*, тим самим формуючи завдання веденому регулятору. Виведення з каскаду веденого регулятору проводиться шляхом переключення *TC1s* в режим слідкування (*Tracking*), подавши на його вхід *TR_s* змінну *TC1s_OFF* (*TC1s.TR_s=TC1s_OFF*). Тобто в режимі слідкування на вихід *TC1s.OUT* буде подаватися значення *TC1s.TR_I=TC1_OUT.* 

Враховуючи вимоги до безударності переходів, та різні режими роботи контуру регулювання, обидва регулятори *TC1* та *TC1s* працюють в режимі використання входу *RCPY* (*en_rcpy=TRUE*). Це значить, що нове значення виходу *OUT* регулятори будуть розраховувати на базі значення входу *RCPY*. Для веденого регулятору *TC1s* на вхід *RCPY* завжди подається значення, яке йде на виконавчий механізм *TV1*. Тобто, якщо ведений регулятор виведений з каскаду, він все одно буде формувати нове значення виходу внутрішнього регулятору на базі плинного *TV1*, що забезпечить безударний перехід при повторному вводі його в каскад. Для ведучого регулятору значення *RCPY* залежить від того, чи включений в контур управління ведений регулятор *TC1s*. Якщо ведений регулятор виведений із каскаду, то *RCPY=TV1*, так як *TC1* безпосередньо управляє виконавчим механізмом, отже нове розраховане значення базується на значенні *TV1*. Якщо ведений регулятор в складі контуру, то *RCPY=LIMIT(TC1_OUT).* Функція обмеження використовується тому, що в режимі (*en_rcpy=TRUE*) обмеження на вихід блоку *PI_B* не діють. 

Реалізація ручного управління. Ручне управління контуру реалізоване через блок ручного управління *HC1* та відповідних режимів роботи регуляторів *TC1* та *TC1s*. Значення виходу *HC1.OUT* зв’язане зі змінною *TV1*. У автоматичному режимі роботи контуру (*TC1_AUTO=TRUE*) вихід *HC1.OUT=TC1s_OUT*. У ручному режимі вихід *HC1.OUT* може бути змінений оператором. При цьому, враховуючи що значення *TV1* повторюється на входах *RCPY* блоків регулювання забезпечується безударний перехід. 

Ведений регулятор завжди знаходиться в автоматичному режимі, так як для ручного режиму передбачений блок *HC1*. Ведучий регулятор, якщо він знаходиться в режимі каскаду з веденим, в ручному режимі повинен фіксувати своє вихідне значення в останньому положенні. Це забезпечується шляхом переключення його в ручний режим. Таким чином ведучий регулятор працює в автоматичному режимі, коли працює в автоматичному режимі весь контур, або коли ведений регулятор виведений з каскаду.

 

### 6.8.3.  Регулювання з використанням виконавчих механізмів типу реверсивний двигун 

Завдання. 

Необхідно створити проект в UNITY PRO для реалізації поставленої задачі (рис.6.69 та рис.6.70) з використанням FFB бібліотеки *ControlLIB*. Налагодження проекту зробити з використанням готового програмного імітатору об’єкту та операторського екрану. 

Технологічна установка являє собою два теплообмінника для підігріву рідкого продукту за допомогою гарячої води. У першому підігрівнику (рис.6.69) температура продукту на виході вимірюється датчиком температури *TT1* (0-100 °C, вхід ПЛК *%IW0.1.2*) який вмонтований на трубопроводі на відстані кількох метрів від підігрівника, а регулюється витратою гарячої води на виході підігрівника з використанням клапану *TV1* і приводом типу МЕО (вихід ПЛК *%Q0.3.16* – "більше", *%Q0.3.17* – "менше"). Додатково вимірюється також температура води в трубопроводі безпосередньо на виході підігрівника за допомогою датчика *ТТ1а* (0-100 °C, вхід ПЛК *%IW0.1.3*). Виконавчий механізм *TV1* має показчик положення регулюючого органу (0-100%, вхід ПЛК *%IW0.1.4*). Час повного відкриття клапану – 10с, мінімальний імпульс – 250 мс. 

Температура продукту на виході другого підігрівника (рис.6.70) вимірюється датчиком температури *TT2* (0-100 °C, вхід ПЛК *%IW0.1.6*), а регулюється витратою гарячої води на виході підігрівника з використанням клапану *TV2* з приводом типу МЕО (вихід ПЛК *%Q0.3.18* – "більше", *%Q0.3.19* – "менше"). Додатково вимірюється також температура води в трубопроводі безпосередньо на виході підігрівника за допомогою датчика *ТТ2а* (0-100 °C, вхід ПЛК *%IW0.1.7*). Виконавчий механізм *TV2* має датчики кінцевого положення регулюючого органу: "повністю відкритий" - вхід ПЛК *%I0.3.0*, "повністю закритий" - вхід ПЛК *%I0.3.1*. Час повного відкриття клапану – 10с, мінімальний імпульс – 250 мс.

Система управління повинна забезпечити регулювання температури *ТТ1* та *ТТ2* з підтримкою наступних функцій:

1)  стабілізація температур на виходах підігрівників на заданому оператором значені, з використанням ПІ регуляторів та блоків управління серводвигунами;

2)  можливість настройки коефіцієнтів *Kp* та *Ti* з операторського екрану;

3)  можливість ручного управління виконавчими механізмами *TV1* та *TV2* з операторського екрану при переключенні в ручний режим з забезпеченням безударності переходу.

 

Рішення.

Перелік змінних та екземплярів функціональних блоків наведені на рис.6.71. 

![](media6/6_69.png)

Рис.6.69. Операторський екран для контролю та управління процесом нагрівання в підігрівнику 1

![](media6/6_70.png)

Рис.6.70. Операторський екран для контролю та управління процесом нагрівання в підігрівнику 2  

![](media6/6_71.png) 

Рис.6.71. Змінні проекту  

Загальні принципи роботи контуру управління температурю в підігрівнику 1. 

Функціональна схема контуру регулювання температури продукту показана на операторському екрані (рис.6.70). 

Контур включає:

-           канали вимірювання (*ТТ1*, *ТТ1а*);

-           регулятор *TC1* (ПІ закон), який на основі сформованого завдання (вхід *SP*) та вимірювального значення (*TT1* на вхід *PV*), формує сигнал управління (вихід *OUT*), що подається на блок управління серводвигуном *TS1*; на вхід *RCPY* регулятору заводиться сигнал зворотного зв’язку по положенню регулюючого органу *ZS1*; для регулятору налаштовуються *Kp* та *Ti*; регулятор може працювати в автоматичному або ручному режимі (вмикається/вимикається кнопка "АВТ"); в ручному режимі вихід *OUT* задається безпосередньо оператором;

-           блок управління серводвигуном *TS1*, який перетворює числовий сигнал що поступає на вхід *IN* в діапазоні 0-100% у дискретні сигнали відповідної тривалості типу "більше" (вихід R) та "менше" (вихід L); на вхід *RCPY* блоку заводиться сигнал зворотного зв’язку по положенню регулюючого органу *ZS1*; 

-           канал управління, який окрім клапану з виконавчим механізмом TV1 включає показчик положення регулюючого органу (*ZS1*);

Структура програми. Для реалізації даної задачі використовуються 5-ть секцій (рис.6.72): секція "*INPUTS*" – для обробки вхідних каналів вимірювання; секція "*OUTPUTS*" – для обробки вихідних каналів правління; секція "*CTRL1*" та "*CTRL2*" – для реалізації контурів управління температурою відповідно в підігрівнику 1 та підігрівнику 2. Секція "*Simulation*" призначена тільки для імітації об’єкта.

![](media6/6_72.png)

Рис.6.72. Структура Задачі MAST 

У секції "*INPUTS*" (рис.6.73) оцифровані значення аналогових входів масштабуються шляхом множення на коефіцієнт (діапазон 0-10000 в 0-100°C). До входів контуру з підігрівачем 1 належить також показник положення *ZS1* (діапазон 0-10000 в 0-100 %ХРО). До входів контуру з підігрівачем 2 належать також датчики кінцевого положення типу "відкрито" - *ZSO2*, та "закрито" - *ZSC2*. 

У секції "*OTPUTS*" (рис.6.74) для кожного виконавчого механізму на виходи ПЛК подаються сигнали "більше" (*TV1_OPN*, *TV2_OPN*) та "менше" (*TV1_CLS*, *TV2_CLS*). 

![](media6/6_73.png) 

Рис.6.73. Секція обробки входів 

![](media6/6_74.png)

Рис.6.74. Секція обробки виходів 

Опис роботи програми реалізації контуру управління температурою в підігрівнику 1.  Програма секції "*CTRL1*" наведена на рис.6.75. Для UNITY PRO V<6.0 вхід/вихід *TC1.OUT* треба розірвати від *TS1* та *SERVO*, а зв’язок реалізувати через змінну *TC1_OUT*. 

![](media6/6_75.png)

Рис.6.75. Секція CTRL1 

Основу контуру складає ПІ-регулятор *TC1*, який на основі плинної температури *TT1* та завдання *TC1_SP* формує на виході *OUT* (прив’язаний до *TC1_OUT*) числове значення, яке подається на блок управління серводвигуном *TS1* для формування імпульсів "більше" та "менше". Регулятор *TC1* працює в режимі використання входу *RCPY* (*TC1_PARA*.*en_rcpy=TRUE*). Це значить, що нове значення виходу *OUT* регулятор буде розраховувати на базі значення входу *RCPY,* на який подається значення покажчика положення *ZS1*. 

 Блок управління серводвигуном *TS1* теж працює в режимі використання входу *RCPY* (*TS1_PARA*.*en_rcpy=TRUE*). Це значить, що він буде перетворювати значення різниці *IN-RCPY* у дискретний сигнал *RAISE* або *LOWER* відповідної тривалості. Значення параметрів блоку дорівнюють *TS1_PARA*.*t_motor=t#10s* та *TS1_PARA*.*t_mini=t#250ms* відповідно до умов задачі.   

Алгоритм роботи блоку *SERVO* працює таким чином, що у ручному режимі він буде видавати сигнали "більше" та "менше" до тих пір, поки *IN* та *RCPY* не будуть рівними. Для того, щоб блок управління серводвигуном в ручному режимі припиняв управління в зоні наближеній до положення *RCPY,* можна створити та використати блок вирівнювання (рис.6.76). Принцип роботи алгоритму заключається в прирівнюванні виходу *RCPY_OUT=IN* в тому випадку, коли в ручному режимі (*MA_I=TRUE*) вхід *IN* буде в зоні наближення до *RCPY*. Величина зони наближення визначається параметром *deadb*, збільшення значення якого зменшує кількість рухів однак збільшує похибку позиціонування.  

![](media6/6_76.png)

Рис.6.76. Структура і програма DFB типу aligRCPY

Блок вирівнювання *TY1_RCPY* включається в схему між *TC1.OUT* та  *SERVO.RCPY.* Тобто, коли *ZS1* знаходиться в зоні *TC1_OUT*, на вхід *TS1.RCPY* буде подаватися значення *TC1_OUT* а не *ZS1*, що приведе до відключення виходів LOWER та RAISE.   

Опис роботи програми реалізації контуру управління температурою в підігрівнику 2.  Програма секції "*CTRL2*" наведена на рис.6.77. 

![](media6/6_77.png)

Рис.6.77. Секція *CTRL2* 

Основу контуру складає ПІ-регулятор *TC2*, який на основі плинної температури *TT2* та завдання *TC2_SP* формує на інкрементальному виході *OUTD* (прив’язаний до *TC2_OUTD*) числове значення, яке подається на блок управління серводвигуном *TS2* для формування імпульсів "більше" та "менше". Регулятор *TC2* працює в режимі без використання входу *RCPY* (*TC1_PARA*.*en_rcpy=FALSE*), саме тому використовується зв’язка інкрементального виходу *TC2.OUTD* та *TS2.INPD*. Це значить, що на кожному циклі блок *TC2* буде розраховувати нове інкрементальне значення виходу *OUTD*, а абсолютне значення *OUT* використовуватися не буде. 

Блок управління серводвигуном *TS2* теж працює в режимі без використання входу *RCPY* (*TS1_PARA*.*en_rcpy=FALSE*). Це значить, що він буде перетворювати значення входу *INPD* у дискретний сигнал *RAISE* або *LOWER* відповідної тривалості. Значення параметрів блоку дорівнюють *TS1_PARA*.*t_motor=t#10s* та *TS1_PARA*.*t_mini=t#250ms* відповідно до умов задачі. 

Алгоритм роботи блоку *SERVO* працює таким чином, що у ручному режимі він буде видавати сигнали "більше" та "менше" відповідно до значення входу *INPD* на кожному циклу. Враховуючи що змінна *TC2_OUTD* обновлюється з періодичністю виклику *TC2* (500 мс), а блок *TS2* з кожним циклом, протягом 500 мс блок *TS2* буде формувати нові імпульси. Для того щоб уникнути цього ефекту, в ручному режимі (*TC2_AUTO=FALSE*) змінна *TC2_OUTD* обнуляється після обробки контуру. 

## Контрольні запитання до розділу

1.   Які апаратні засоби є вбудовані в TSX Premium для реалізації контурів регулювання?

2.   З яких основних частин складається прикладна програма ПЛК для реалізації контурів регулювання? Поясніть призначення кожної з цих частин. 

3.   Блоки FFB яких бібліотек використовуються для реалізації контурів регулювання в UNITY PRO? Які з них використовуються тільки для сумісності з проектами PL7 та Concept?

4.   Блоки FFB якої бібліотеки рекомендується для реалізації контурів регулювання в UNITY PRO? Чи обов’язково користуватися для задач регулювання блоками саме цієї бібліотеки?

5.   Поясніть призначення та особливості функціонування режиму слідкування (*Tracking*) FFB-блоків бібліотеки *ControllLIB*. Який пріоритет має цей режим по відношенню до режиму ручний/автомат?

6.   Поясніть призначення та особливості функціонування ручного та автоматичного режимів FFB-блоків бібліотеки *ControllLIB*. Який пріоритет має цей режим по відношенню до режиму слідкування? 

7.   Яким чином контролюється виконання FFB бібліотеки *ControllLIB*? Які типові помилки можуть виникнути при обробці блоку?

8.   Чи обов’язково викликати блоки регуляторів *ControllLIB* строго періодично?

9.   Розкажіть про призначення FFB блоків сімейства *Controller* бібліотеки *ControllLIB*. 

10.            Розкажіть про призначення та функціонування *SAMPLETM*. Чи обов’язкове їх використання тільки з блоками регуляторів?

11.            Використовуючи функціональну схему поясніть основні принципи роботи блоку регулятору *PI_B*.

12.            Яким чином блок *PI_B* переводиться в П- та ПІ-режим регулювання? Поясніть відмінності роботи цих режимів.

13.            Поясніть призначення полів структури *Para_PI_B* .

14.            Використовуючи функціональну схему поясніть основні принципи роботи блоку регулятору *PIDFF*.

15.            Поясніть призначення полів структури *Para_PIDFF* .

16.            Чим відрізняється вихід *OUTD* від *OUT* в регуляторах блоків PI_B та PIDFF? Навіщо кожен з них використовується?

17.            Розкажіть про призначення входу *RCPY*. Як активувати режим використання *RCPY*?

18.            Розкажіть про функціонування блоків *PI_B/PIDFF* в режимі абсолютного розрахунку.

19.            Розкажіть про функціонування блоків *PI_B/PIDFF* в інкрементальному режимі роботи.

20.            Як Ви розумієте термін безударність переходу? Між якими режимами і яким чином реалізована безударність переходу в блоках *PI_B* та *PIDFF*?

21.            Розкажіть про призначення та функціонування *STEP2*.

22.            Розкажіть про призначення та функціонування *STEP3*.

23.            Розкажіть про призначення та функціонування *HYST*.

24.            Розкажіть про призначення та функціонування *INDLIM*.

25.            Розкажіть про призначення та функціонування процедури *LOOKUP_TABLE*.

26.            Розкажіть про призначення та функціонування *DEAD_ZONE*.

27.            Розкажіть про призначення та функціонування *SAH*.

28.            Розкажіть про призначення та функціонування *AVGMV* та *AVGMV_K*. 

29.            Розкажіть про призначення та функціонування *K_SQRT*.

30.            Розкажіть про призначення та функціонування *MFLOV*.

31.            Розкажіть про призначення та функціонування *MULDIV_W* та *SUM_W*.

32.            Розкажіть про призначення та функціонування *SERVO*. 

33.            Яким чином блоки управління серводвигунами можуть визначати положення регулюючого органу?

34.            Як контролюється блоком *SERVO* досягнення регулюючим органом крайніх положень? Як при цьому веде себе блок?

35.            Які особливості обробки серводвигунів в автоматичному та ручному режимах? Розкажіть про призначення входу *SEN*.

36.            Розкажіть про роботу блоку управління серводвигуном в режимі активації *RCPY*? Як при цьому правильно з’єднувати *SERVO* та регулятор? Що необхідно передбачити в програмі в ручному режимі?

37.            Розкажіть про роботу блоку управління серводвигуном в режимі без *RCPY*? Як при цьому правильно з’єднувати *SERVO* та регулятор? Що необхідно передбачити в програмі в ручному режимі?

38.            Навіщо задаються в блоці управління серводвигунами параметри *t_motor* та  *t_mini*?

39.            Розкажіть про призначення та функціонування *PWM1*. 

40.            Розкажіть про призначення та функціонування *MS*. У яких випадках необхідно використовувати цей функціональний блок?

41.            Розкажіть про призначення та функціонування *SP_SEL*. 

42.            Розкажіть про призначення та функціонування *RAMP*. 

43.            Розкажіть про призначення та функціонування *RATIO*. 

44.            Розкажіть про призначення та функціонування *SCALING*. 

45.            Розкажіть про призначення та функціонування *DTIME*. 

46.            Розкажіть про призначення та функціонування *INTEGRATOR*. 

47.            Розкажіть про призначення та функціонування *LAG_FILTER*. 

48.            Розкажіть про призначення та правила використання процедур цілочисельного регулювання. У якому режимі повинна виконуватися задача, в якій ці процедури виконуються?

49.            Розкажіть про призначення та функціонування *PID_INT*. 

50.            Розкажіть про призначення та функціонування *SERVO_INT*. 

51.            Розкажіть про призначення та функціонування *PWM_INT*. 